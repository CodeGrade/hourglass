{"answers":[[[{"text":"// this method would be located in an ArrayUtils class\n\n// takes an ArrayList of Doubles and an integer n, and produces a new ArrayList containing all the averages of\n// each consecutive sequence of n numbers in the given ArrayList, such that the averages of sequences that occur\n// earlier in the given ArrayList come first in the resulting ArrayList\nArrayList\u003cDouble\u003e runningAverages(ArrayList\u003cDouble\u003e source, int n) {\n  // throws an error if n is less than 1 or greater than the length of the source ArrayList\n  if (n \u003c 1 || n \u003e source.size()) {\n    throw new IllegalArgumentException(\"Cannot produce consecutive sequences of the desired length in the given ArrayList.\");\n  }\n  \n  ArrayList\u003cDouble\u003e dest = new ArrayList\u003cDouble\u003e();\n  \n  // iterates through the source ArrayList and processes each possible consecutive sequence of numbers of length\n  // n; the value of i on each iteration corresponds to the index of the starting number in the sequence on that\n  // iteration\n  for (int i = 0; i \u003c= source.size() - n; i += 1) {\n    double sum = 0;\n    \n    // iterates through the sequence of n numbers that starts at the current index and sums them all\n    for (int j = 0; j \u003c n; j += 1) {\n      sum += source.get(i + j);\n    }\n    // computes the average by dividing the sum obtained above by the count of numbers in the\n    // sequence, which is n\n    double avg = sum / n;\n    \n    dest.add(avg);\n  }\n  \n  return dest;\n}\n\n// test cases (using -\u003e shorthand instead of writing t.checkExpect each time; this notation was allowed on the first exam)\n\n// checks the basic functionality of the method: that it returns the appropriate running averages in the correct order\n// NOTE: (1.0 + 2.0) / 2 = 3.0 / 2 = 1.5 and (2.0 + 5.0) / 2 = 7.0 / 2 = 3.5\nrunningAverages(Arrays.asList(1.0, 2.0, 5.0), 2) -\u003e Arrays.asList(1.5, 3.5);\n\n// checks the functionality of the method for a larger value of n as well as a source ArrayList that is not sorted\n// in any way\n// NOTE: (1.0 + 2.0 + 1.5) / 3 = 4.5 / 3 = 1.5, (2.0 + 1.5 + 5.5) / 3 = 9.0 / 3 = 3.0, and (1.5 + 5.5 - 1.0) / 3 = 6.0 / 3 = 2.0\nrunningAverages(Arrays.asList(1.0, 2.0, 1.5, 5.5, -1.0), 3) -\u003e Arrays.asList(1.5, 3.0, 2.0);\n\n// checks that attempting to pass in a value of n less than 1 results in an error\nrunningAverages(Arrays.asList(1.0, 2.0, 3.0), 0) -\u003e\n  new IllegalArgumentException(\"Cannot produce consecutive sequences of the desired length in the given ArrayList.\");\n\n// checks that attempting to pass in a value of n greater than the allowable limit, the length of the source ArrayList,\n// results in an error\nrunningAverages(Arrays.asList(1.0), 2) -\u003e\n  new IllegalArgumentException(\"Cannot produce consecutive sequences of the desired length in the given ArrayList.\");","marks":[]}],[{"text":"// these methods would be located in an ArrayUtils class\n\n// takes an ArrayList of Doubles containing numbers to be averaged and an ArrayList of Doubles containing weights,\n// and produces a new ArrayList containing all the weighted moving averages obtained by sliding the list of weights\n// across the source list of numbers\nArrayList\u003cDouble\u003e weightedRunningAverages(ArrayList\u003cDouble\u003e source, ArrayList\u003cDouble\u003e weights) {\n  // throws an error if the weight list is empty or larger than the source list\n  if (weights.size() \u003c 1 || weights.size() \u003e source.size()) {\n    throw new IllegalArgumentException(\"Cannot use given list of weights to produce weighted moving averages across source ArrayList.\");\n  }\n  \n  double totalWeight = 0;\n  // computes the total weight by iterating through the weight list and summing all the weights in the list\n  for (Double weight : weights) {\n    totalWeight += weight;\n  }\n  \n  ArrayList\u003cDouble\u003e dest = new ArrayList\u003cDouble\u003e();\n  \n  // iterates through the source ArrayList and processes each consecutive sequence of numbers, calculating\n  // their weighted average using the given weights; the value of i on each iteration corresponds to the\n  // index of the starting number in the sequence on that iteration\n  for (int i = 0; i \u003c= source.size() - weights.size(); i += 1) {\n    double weightedSum = 0;\n    \n    // iterates through the sequence of numbers starting at the current index and computes their weighted\n    // sum\n    for (int j = 0; j \u003c weights.size(); j += 1) {\n      weightedSum += source.get(i + j) * weights.get(j);\n    }\n    \n    // computes the weighted average by dividing the weighted sum by the total weight\n    double avg = weightedSum / totalWeight;\n    \n    dest.add(avg);\n  }\n  \n  return dest;\n}\n\n// this method would be located in an ArrayUtils class\n\n// takes an ArrayList of Doubles and an integer n, and produces a new ArrayList containing all the averages of\n// each consecutive sequence of n numbers in the given ArrayList, such that the averages of sequences that occur\n// earlier in the given ArrayList come first in the resulting ArrayList\nArrayList\u003cDouble\u003e runningAverages(ArrayList\u003cDouble\u003e source, int n) {\n  // throws an error if n is less than 1 or greater than the length of the source ArrayList\n  if (n \u003c 1 || n \u003e source.size()) {\n    throw new IllegalArgumentException(\"Cannot produce consecutive sequences of the desired length in the given ArrayList.\");\n  }\n  else {\n    ArrayList\u003cDouble\u003e weights = new ArrayList\u003cDouble\u003e();\n    // produces an ArrayList of length n where each weight is 1\n    for (int i = 0; i \u003c n; i += 1) {\n      weights.add(1);\n    }\n    \n    // computes a weighted average with n weights, such that each weight is 1 (i.e. all numbers are\n    // weighted equally)\n    return this.weightedRunningAverages(source, weights);\n  }\n}\n\n// test cases\n\n// checks that calculating an unweighted average using weights 1 should still work\n// see first test of previous answer\nweightedRunningAverages(Arrays.asList(1.0, 2.0, 5.0), Arrays.asList(1.0, 1.0)) -\u003e Arrays.asList(1.5, 3.5);\n\n// checks the functionality of the method for differing weights\n// NOTE: (3.0 * 1.0 + 1.5 * 2.0) / 3.0 = 6.0 / 3.0 = 2.0 and (1.5 * 1.0 + 1.5 * 2.0) / 3.0 = 1.5 \nweightedRunningAverages(Arrays.asList(3.0, 1.5, 1.5), Arrays.asList(1.0, 2.0)) -\u003e Arrays.asList(2.0, 1.5);\n\n// checks that attempting to pass in an empty list of weights results in an error\nweightedRunningAverages(Arrays.asList(1.0, 2.0, 3.0), new ArrayList\u003cDouble\u003e()) -\u003e\n  new IllegalArgumentException(\"Cannot use given list of weights to produce weighted moving averages across source ArrayList.\");\n\n// checks that attempting to pass in a list of weights longer than the source list of numbers results in an error\nweightedRunningAverages(Arrays.asList(1.0), Arrays.asList(1.0, 2.0)) -\u003e\n  new IllegalArgumentException(\"Cannot use given list of weights to produce weighted moving averages across source ArrayList.\");","marks":[]}]],[[{"text":"// in ANode:\n// EFFECT: attempts to swap this node with its next neighboring node\nabstract void swapWithNext();\n\n// EFFECT: attempts to swap this node with the given Node\nabstract void swapWithPrevNode(Node\u003cT\u003e prevNode);\n\n// EFFECT: sets this node's next neighbor to the given node, and the given node's prev neighbor to this node\nvoid setNextNeighbor(ANode\u003cT\u003e newNext) {\n  this.next = newNext;\n  newNext.prev = this;\n}\n\n// EFFECT: sets this node's prev neighbor to the given node, and the given node's next neighbor to this node\nvoid setPrevNeighbor(ANode\u003cT\u003e newPrev) {\n  this.prev = newPrev;\n  newPrev.next = this;\n}\n\n// in Sentinel:\n// EFFECT: does nothing, because a Sentinel is not a data-bearing Node and therefore should not be swapped\npublic void swapWithNext() {\n  return;\n}\n\n// EFFECT: does nothing, because a Sentinel is not a data-bearing Node and therefore should not be swapped\npublic void swapWithPrevNode(Node\u003cT\u003e prevNode) {\n  return;\n}\n\n// in Node:\n// EFFECT: if this Node's next neighbor is also a data-bearing Node, swaps this node with its next neighbor\npublic void swapWithNext() {\n  this.next.swapWithPrevNode(this);\n}\n\n// EFFECT: swaps this Node with its previous Node neighbor\npublic void void swapWithPrevNode(Node\u003cT\u003e prevNode) {\n  ANode\u003cT\u003e curNext = this.next;\n  ANode\u003cT\u003e curPrevPrev = prevNode.prev;\n  \n  // sets this Node's next and prev neighbors to the other Node's old neighbors\n  this.setNext(prevNode);\n  this.setPrev(curPrevPrev);\n  \n  // sets the other Node's next and prev neighbors to this node's old neighbors\n  prevNode.setNext(curNext);\n  prevNode.setPrev(this); // not strictly necessary, but looks nice to have\n}\n\n// test cases\nANode\u003cInteger\u003e node1 = new Node\u003c\u003e(1);\nANode\u003cInteger\u003e node2 = new Node\u003c\u003e(2);\nANode\u003cInteger\u003e node3 = new Node\u003c\u003e(3, node1, node1);\nANode\u003cInteger\u003e sent = new Sentinel\u003c\u003e();\n\n// tests that setting the next neighbor of a Node works properly\nnode3.prev -\u003e node1;\nnode2.next -\u003e null;\nnode2.setNextNeighbor(node3);\nnode3.prev -\u003e node2;\nnode2.next -\u003e node3;\n\n// as well as setting the next neighbor of a Sentinel\nnode1.prev -\u003e node3;\nsent.next -\u003e null;\nsent.setNextNeighbor(node1);\nnode1.prev -\u003e sent;\nsent.next -\u003e node1;\n\n// tests that setting the prev neighbor of a Node works properly\nnode1.next -\u003e node3;\nnode2.prev -\u003e null;\nnode2.setPrevNeighbor(node1);\nnode1.next -\u003e node2;\nnode2.prev -\u003e node1;\n\n// as well as setting the prev neighbor of a Sentinel\nnode3.next -\u003e node1;\nsent.prev -\u003e null;\nsent.setPrevNeighbor(node3);\nnode3.next -\u003e sent;\nsent.prev -\u003e node3;\n\n// checking that all the Nodes and the Sentinel are properly ordered now\nnode1.prev -\u003e sent;\nnode1.next -\u003e node2;\nnode2.prev -\u003e node1;\nnode2.next -\u003e node3;\nnode3.prev -\u003e node2;\nnode3.next -\u003e sent;\nsent.prev -\u003e node3;\nsent.next -\u003e node1;\n\n// checks that swapping a Node with its next neighbor, which is a Node, swaps them properly\nnode1.prev -\u003e sent;\nnode1.next -\u003e node2;\nnode2.prev -\u003e node1;\nnode2.next -\u003e node3;\n\nnode1.swapWithNext();\n\nnode1.prev -\u003e node2;\nnode1.next -\u003e node3;\nnode2.prev -\u003e sent;\nnode2.next -\u003e node1;\n\n// and that if the next neighbor is a Sentinel, nothing happens\nnode3.prev -\u003e node1;\nnode3.next -\u003e sent;\nsent.prev -\u003e node3;\nsent.next -\u003e node2;\n\nnode3.swapWithNext();\n\nnode3.prev -\u003e node1;\nnode3.next -\u003e sent;\nsent.prev -\u003e node3;\nsent.next -\u003e node2;\n\n// and that a Sentinel will not swap with its next neighbor\nsent.prev -\u003e node3;\nsent.next -\u003e node2;\nnode2.prev -\u003e sent;\nnode2.next -\u003e node1;\n\nsent.swapWithNext();\n\nsent.prev -\u003e node3;\nsent.next -\u003e node2;\nnode2.prev -\u003e sent;\nnode2.next -\u003e node1;\n\n// checks that swapping with the given previous node works as intended (swaps neighbor if called on a Node, does nothing if called on Sentinel)\nsent.prev -\u003e node3;\nsent.next -\u003e node2;\nnode2.prev -\u003e sent;\nnode2.next -\u003e node1;\nnode1.prev -\u003e node2;\nnode1.next -\u003e node3;\nnode3.prev -\u003e node1;\nnode3.next -\u003e sent;\n\nnode1.swapWithPrevNode(node2);\n\nsent.prev -\u003e node3;\nsent.next -\u003e node1;\nnode2.prev -\u003e node1;\nnode2.next -\u003e node3;\nnode1.prev -\u003e sent;\nnode1.next -\u003e node2;\nnode3.prev -\u003e node2;\nnode3.next -\u003e sent;\n\nsent.swapWithPrevNode(node3);\n\nsent.prev -\u003e node3;\nsent.next -\u003e node1;\nnode2.prev -\u003e node1;\nnode2.next -\u003e node3;\nnode1.prev -\u003e sent;\nnode1.next -\u003e node2;\nnode3.prev -\u003e node2;\nnode3.next -\u003e sent;","marks":[]}],[{"text":"// in Deque:\n// EFFECT: swaps adjacent sets of neighbors within this Deque; if the size of the Deque is odd, the last item is not swapped\nvoid swapPairs() {\n  this.header.next.swapPairsAlternating(true); // accessing field of Sentinel, as per problem statement, is allowed\n}\n\n// in ANode:\n// EFFECT: swaps adjacent sets of neighbors among all nodes accessible from this one, if the targeted node has a next neighbor\n// which is a Node, while keeping track of whether or not to attempt a swap so that pairs do not get swapped twice\nabstract void swapPairsAlternating(boolean doSwap);\n\n// in Sentinel:\n// EFFECT: does nothing, because the sentinel cannot be swapped\npublic void swapPairsAlternating(boolean doSwap) {\n  return;\n}\n\n// in Node:\n// EFFECT: swaps adjacent sets of neighbors among all nodes accessible from this one, if the targeted node has a next neighbor\n// which is a Node, while keeping track of whether or not to attempt a swap so that pairs do not get swapped twice\npublic void swapPairsAlternating(boolean doSwap) {\n  if (doSwap) {\n    this.swapWithNext();\n  }\n  \n  this.next.swapPairsAlternating(!doSwap);\n}\n\n// test cases\nDeque\u003cInteger\u003e emptyDeque = new Deque\u003c\u003e();\n\n// tests that swapping pairs in an empty deque does nothing, because there are no pairs to swap\nemptyDeque.size() -\u003e 0;\nemptyDeque.swapPairs();\nemptyDeque.size() -\u003e 0;\n\n// tests that swapping pairs in a nonempty deque of even length correctly swaps the values\nDeque\u003cInteger\u003e evenLengthDeque = new Deque\u003c\u003e();\noddLengthDeque.addToTail(1);\noddLengthDeque.addToTail(2);\noddLengthDeque.addToTail(3);\noddLengthDeque.addToTail(4);\n\nevenLengthDeque.swapPairs();\n\n// 2 swaps with 1 and 4 swaps with 3\nDeque\u003cInteger\u003e expected = new Deque\u003c\u003e();\nexpected.addToTail(2);\nexpected.addToTail(1);\nexpected.addToTail(4);\nexpected.addToTail(3);\n\nevenLengthDeque -\u003e expected\n\n// tests that swapping pairs in a nonempty deque of odd length swaps all pairs and leaves the last value untouched\nDeque\u003cInteger\u003e oddLengthDeque = new Deque\u003c\u003e();\noddLengthDeque.addToTail(1);\noddLengthDeque.addToTail(2);\noddLengthDeque.addToTail(3);\n\noddLengthDeque.swapPairs();\n\n// 2 swaps with 1 and 3 is unchanged\nDeque\u003cInteger\u003e expected = new Deque\u003c\u003e();\nexpected.addToTail(2);\nexpected.addToTail(1);\nexpected.addToTail(3);\n\noddLengthDeque -\u003e expected","marks":[]}],[{"text":"// in Deque:\n// EFFECT: performs two pair swaps, the first starting from the first item in the Deque and the second skipping the first item\nvoid swapPairsTwice() {\n  this.header.next.swapPairsAlternating(true);\n  this.header.next.swapPairsAlternating(false);\n}\n\n// test cases\nDeque\u003cString\u003e emptyDeque = new Deque\u003c\u003e();\n\n// tests that swapping pairs twice in an empty deque does nothing, because there are no pairs to swap\nemptyDeque.size() -\u003e 0;\nemptyDeque.swapPairsTwice();\nemptyDeque.size() -\u003e 0;\n\n// tests that swapping pairs in a nonempty deque of even length first swaps the values pairwise starting from\n// the first element, then performs another pairwise swap starting from the second element\nDeque\u003cString\u003e evenLengthDeque = new Deque\u003c\u003e();\nevenLengthDeque.addToTail(\"A\");\nevenLengthDeque.addToTail(\"B\");\nevenLengthDeque.addToTail(\"C\");\nevenLengthDeque.addToTail(\"D\");\n\nevenLengthDeque.swapPairsTwice();\n\n// initial deque: (A B C D)\n// first swap: B and A swap, and D and C swap -\u003e (B A D C)\n// second swap: D and A swap, and B and C are left alone -\u003e (B D A C)\nDeque\u003cInteger\u003e expected = new Deque\u003c\u003e();\nexpected.addToTail(\"B\");\nexpected.addToTail(\"D\");\nexpected.addToTail(\"A\");\nexpected.addToTail(\"C\");\n\nevenLengthDeque -\u003e expected\n\n// tests that swapping pairs in a nonempty deque of odd length first swaps the values pairwise starting from\n// the first element, then performs another pairwise swap starting from the second element\nDeque\u003cString\u003e oddLengthDeque = new Deque\u003c\u003e();\noddLengthDeque.addToTail(\"A\");\noddLengthDeque.addToTail(\"B\");\noddLengthDeque.addToTail(\"C\");\n\noddLengthDeque.swapPairs();\n\n// initial deque: (A B C)\n// first swap: B and A swap, C is unchanged -\u003e (B A C)\n// second swap: C and A swap, B is unchanged -\u003e (B C A)\nDeque\u003cInteger\u003e expected = new Deque\u003c\u003e();\nexpected.addToTail(\"B\");\nexpected.addToTail(\"C\");\nexpected.addToTail(\"A\");\n\noddLengthDeque -\u003e expected","marks":[]}]],[[{"text":"// represents an iterator that produces the sequence of values necessary to continue playing the game\nclass SimonSaysPlayer\u003cT\u003e implements Iterator\u003cT\u003e {\n  Iterator\u003cT\u003e gameSource;\n  ArrayList\u003cT\u003e seenValues;\n  ArrayList\u003cT\u003e nextValues;\n  \n  // takes an iterator representing the values output by the game, and constructs a new SimonSaysPlayer\n  SimonSaysPlayer(Iterator\u003cT\u003e gameSource) {\n    this.gameSource = gameSource;\n    this.seenValues = new ArrayList\u003cT\u003e();\n    this.nextValues = new ArrayList\u003cT\u003e();\n  }\n  \n  // returns whether this iterator has a next value\n  public boolean hasNext() {\n    if (this.nextValues.size() == 0) {\n      return this.gameSource.hasNext();\n    } else {\n      return true;\n    }\n  }\n  \n  // returns the next value that the player would have to produce\n  // EFFECT: updates the lists of total seen values and pending values\n  public T next() {\n    // throws an error if this iterator does not have a next value\n    if (!this.hasNext()) {\n      throw new IllegalStateException(\"Iterator does not have a next value.\");\n    }\n    \n    // if there are no pending values, gets the next value from the gameSource iterator, adds it to the list of seen\n    // values, and then adds all the values from the list of seen values into the list of pending values, starting\n    // from the very first value\n    if (this.nextValues.size() == 0) {\n      T nextValue = this.gameSource.next();\n      this.seenValues.add(nextValue);\n      // iterates through seenValues and adds all the values that have already been seen to the pending list of values\n      // to be output, which is nextValues\n      for (T val : seenValues) {\n        this.nextValues.add(val);\n      }\n    }\n    \n    // returns the next value to be produced, which is the first\n    T curValue = this.seenValues.get(0);\n    this.seenValues.remove(0);\n    return curValue;\n  }\n}\n\n// test cases\n// NOTE: \"gameSource\" is an iterator that produces the following Strings as its first three outputs:\n// - \"A\"\n// - \"B\"\n// - \"Z\"\n// and has no other values after that\nIterator\u003cString\u003e gameSource = Arrays.asList(\"A\", \"B\", \"Z\").iterator();\nIterator\u003cString\u003e simon = new SimonSaysPlayer\u003cString\u003e(gameSource);\n\n// checks that the simon iterator currently has a next value, since the game is still in progress\n// i.e. the gameSource iterator still has a next value\nsimon.hasNext() -\u003e true;\n\n// checks that the next value returned by the simon iterator is the value \"A\"\nsimon.next() -\u003e \"A\";\n\n// checks that the simon iterator currently has a next value, since the game is still in progress\n// i.e. the gameSource iterator still has a next value\nsimon.hasNext() -\u003e true;\n\n// checks that the next value returned by the simon iterator is the value \"A\"\nsimon.next() -\u003e \"A\";\n\n// checks that the simon iterator currently has a next value, since there is currently a pending value\n// that has not been output yet\nsimon.hasNext() -\u003e true;\n\n// checks that the next value returned by the simon iterator is the value \"B\"\nsimon.next() -\u003e \"B\";\n\n// checks that the simon iterator currently has a next value, since the game is still in progress\n// i.e. the gameSource iterator still has a next value\nsimon.hasNext() -\u003e true;\n\n// checks that the next value returned by the simon iterator is the value \"A\"\nsimon.next() -\u003e \"A\";\n\n// checks that the simon iterator currently has a next value, since there is currently a pending value\n// that has not been output yet\nsimon.hasNext() -\u003e true;\n\n// checks that the next value returned by the simon iterator is the value \"B\"\nsimon.next() -\u003e \"B\";\n\n// checks that the simon iterator currently has a next value, since there is currently a pending value\n// that has not been output yet\nsimon.hasNext() -\u003e true;\n\n// checks that the next value returned by the simon iterator is the value \"Z\"\nsimon.next() -\u003e \"Z\";\n\n// checks that the simon iterator no longer has a next value, since the gameSource iterator has already output\n// its last value, \"Z\", and therefore has no next value, and there are no pending values left to be output\nsimon.hasNext() -\u003e false;\n\n// checks that attempting to call the next method on simon again throws an error, since simon has no next value\nsimon.next() -\u003e new IllegalStateException(\"Iterator does not have a next value.\");","marks":[]}],["Since hasNext() either calls this.gameSource.hasNext(), which has O(1) time and space complexity, or simply returns true, and the conditional takes O(1) time and space, hasNext() has O(1) time and space complexity.\n\nThe next() method has a time complexity of O(n) and a space complexity of O(n) in the worst case, where n is the number of times the method has already been called, i.e. the number of values that have already been produced.\n\n- Time complexity: the initial if statement, call to hasNext(), and exception handling all happen in O(1) time, since hasNext() has O(1) time complexity. In the worst case, this.nextValues.size() is equal to 0. Calling this.gameSource.next() and assigning its value to nextValue takes O(1) time as specified in the problem statement. Adding to an ArrayList takes O(1) time. The for loop, which loops through the entirety of seenValues, will take an amount of time linearly proportional to the size of seenValues, which itself depends linearly on the number of times the next() method has been called. Since the body of the for loop (adding to an ArrayList) takes constant time, the entire loop takes O(n) time where n is the number of times next() has been called. The remainder of the method (getting an item at an index in an ArrayList, assigning that to a local variable, removing from an ArrayList, returning a value) all takes constant time. Therefore, the next() method has O(n) time complexity, where n is the number of times next() has been called.\n\n- Space complexity: the SimonSaysPlayer class contains gameSource, an ArrayList seenValues, and an ArrayList nextValues. As stated by the problem statement, gameSource takes up O(1) space. However, the size of seenValues increases by 1 each time the next() method is called. Therefore, the size of seenValues scales linearly with the number of times next() has been called; if that value is called n, then seenValues takes up O(n) space. In the worst case, nextValues is the same size as seenValues, or O(n) space. The method does not create any other objects. Therefore, the next() method has O(n) space complexity, where n is the number of times next() has been called."],[{"text":"/* This is impossible. In order for checkIterators to return 0, the else if condition in the for loop must trigger on the very first iteration of the loop.\nThis would mean that the first value returned by ss1.next() is not equal to the first value returned by ss2.next().\n\nLet x be the first item returned by the src iterator. Since this is the first time that either ss1.next() or ss2.next() is called, and both ss1 and ss2 are\nSimonSaysPlayer iterators constructed using the src iterator, the value output by both next() methods on this iteration of the loop must be x. This implies\nthat ss1.next() must equal ss2.next(). Therefore, that else if condition cannot be triggered, so the method will never return 0. */","marks":[]},{"text":"Iterator\u003cInteger\u003e src = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11).iterator();\ncheckIterators(src) -\u003e -1","marks":[]},{"text":"/* This is impossible.\n\nSince ss1 and ss2 are initialized at the same time using the same iterator, and at every point where either next() method is called, the other is also called,\nthis means that ss1 and ss2 will always contain the exact same values at any given time. Therefore, the values output by ss1.next() and ss2.next() are always\nthe same, so the else if condition will never trigger.\n\ncheckIterators can only produce a positive result precisely when that condition triggers.\n\nOne could use induction to prove this more rigorously. */","marks":[]}]],[["Dustin Zhang, 8:59"]]],"scratch":""}